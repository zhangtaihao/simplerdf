<?php
// $Id$
/**
 * @file
 * Main module file.
 */

/** Default node URI generator. */
define('SIMPLERDF_DEFAULT_NODEURI_GENERATOR', 'raw');

/** Default format to use for displaying RDF triples. */
define('SIMPLERDF_DEFAULT_FORMAT', 'RDFXML');

/**
 * Implements hook_perm().
 */
function simplerdf_perm() {
  return array('administer simplerdf', 'administer simplerdf settings', 'administer simplerdf mappings');
}

/**
 * Implements hook_theme().
 */
function simplerdf_theme() {
  module_load_include('inc', 'simplerdf', 'includes/simplerdf.theme');
  return _simplerdf_theme();
}

/**
 * Implements hook_features_api().
 */
function simplerdf_features_api() {
  module_load_include('inc', 'simplerdf', 'includes/simplerdf.features');
  return _simplerdf_features_api();
}

/**
 * Implements hook_menu().
 */
function simplerdf_menu() {
  module_load_include('inc', 'simplerdf', 'includes/simplerdf.menu');
  return _simplerdf_menu();
}

/**
 * Implements hook_init().
 */
function simplerdf_init() {
  if (variable_get('simplerdf_rel_index', FALSE)) {
    variable_set('simplerdf_rel_index', FALSE);
    simplerdf_clear_cache('node');

    // Re-index
    simplerdf_rel_unregister('node');
    $result = db_query('SELECT nid FROM {node}');
    while ($nid = db_result($result)) {
      $node = node_load($nid, NULL, TRUE);
      module_invoke_all('simplerdf_rel_save', 'node', $node);
    }
  }
}

/**
 * Wildcard loader for node URI generator settings.
 *
 * @param string $name
 *   Machine name of generator.
 *
 * @return array
 *   Node URI generator plugin array.
 */
function simplerdf_nodeuri_settings_load($name) {
  ctools_include('plugins');
  $plugin = ctools_get_plugins('simplerdf', 'nodeuri_generators', $name);
  if (!empty($plugin['settings form'])) {
    return $plugin;
  }
}

/**
 * Implements hook_flush_caches().
 */
function simplerdf_flush_caches() {
  return array('cache_simplerdf');
}

/**
 * Clear caches.
 *
 * @param string $type
 *   Type of cache to clear; if not specified, clears all cache. If type is
 *   'node', 'term', or 'user', caches for dependent objects are also cleared
 *   (dependent objects must be registered through simplerdf_rel_register()).
 *   Can be one of:
 *   - 'node' : Node caches, with node ID optionally specified.
 *   - 'term' : Term caches, with term ID optionally specified (only if simplerdf_taxonomy is enabled).
 *   - 'user' : User caches, with user ID optionally specified (only if simplerdf_user is enabled).
 *   - 'fields' : Fields cache, for subsequent rebuild, with content type optionally specified.
 *   - 'mappings' : Mappings cache, with content type optionally specified.
 * @param $a1
 *   Parameter to use when clearing cache, depending on $type:
 *   - If $type is 'node', 'term', or 'user', this can be the respective object
 *     ID. If this is notspecified, cache for all objects of that type will be
 *     cleared.
 *   - If $type is 'mappings', specifying the content type clears mappings
 *     cache for that type, or all types if not specified.
 */
function simplerdf_clear_cache($type = NULL, $a1 = NULL) {
  // Clear all caches
  if (!$type) {
    cache_clear_all('*', 'cache_simplerdf', TRUE);
  }

  // Fields cache
  elseif ($type == 'fields') {
    if ($a1) {
      cache_clear_all('fields:' . $a1, 'cache_simplerdf');
      cache_clear_all('content_fields:' . $a1, 'cache_simplerdf');
    }
    else {
      cache_clear_all('fields:', 'cache_simplerdf', TRUE);
      cache_clear_all('content_fields:', 'cache_simplerdf', TRUE);
    }
    // Force rebuild
    _simplerdf_build_content_fields(NULL, TRUE);
    _simplerdf_build_fields(NULL, TRUE);
  }

  // Mappings cache
  elseif ($type == 'mappings') {
    if ($a1) {
      // Clear for type
      cache_clear_all('mappings:' . $a1, 'cache_simplerdf');
    }
    else {
      // Clear all
      cache_clear_all('mappings:', 'cache_simplerdf', TRUE);
    }
  }

  // Basic object cache
  elseif ($type && (!isset($a1) || $a1)) {
    if (!$a1) {
      // Clear for all
      cache_clear_all($type . ':', 'cache_simplerdf', TRUE);
      // All node dependencies
      $deps = simplerdf_rel_lookup(NULL, NULL, 'node');
    }
    else {
      // Clear itself and dependencies
      cache_clear_all($type . ':' . $a1 . ':', 'cache_simplerdf', TRUE);
      $deps = simplerdf_rel_lookup(NULL, NULL, 'node', $a1);
    }
    foreach ($deps as $dep) {
      cache_clear_all($dep['source_type'] . ':' . $dep['source_id'] . ':', 'cache_simplerdf', TRUE);
    }
  }
}

/**
 * Alias of simplerdf_clear_cache() for all caches. This function is useful for
 * handling submission of altered form just to clear cache.
 */
function simplerdf_clear_cache_all() {
  simplerdf_clear_cache();
}

/**
 * Register an object dependency relation.
 *
 * @param $source_type
 *   Source object type (e.g. node).
 * @param $source_id
 *   Source object ID.
 * @param $target_type
 *   Target object type (e.g. node).
 * @param $target_id
 *   Target object ID.
 *
 * @see simplerdf_rel_unregister()
 * @see simplerdf_rel_lookup()
 */
function simplerdf_rel_register($source_type, $source_id, $target_type, $target_id) {
  if ($source_type && $source_id && $target_type && $target_id) {
    @db_query("INSERT INTO {simplerdf_rel} (source_type, source_id, target_type, target_id) VALUES ('%s', '%s', '%s', '%s')", $source_type, $source_id, $target_type, $target_id);
  }
}

/**
 * Unregister object relation(s).
 *
 * @param $source_type
 *   Source object type (e.g. node).
 * @param $source_id
 *   Source object ID.
 * @param $target_type
 *   Target object type (e.g. node).
 * @param $target_id
 *   Target object ID.
 *
 * @see simplerdf_rel_register()
 * @see simplerdf_rel_lookup()
 */
function simplerdf_rel_unregister($source_type = NULL, $source_id = NULL, $target_type = NULL, $target_id = NULL) {
  $source_id = (int) $source_id;
  $target_id = (int) $target_id;
  $filters = array_filter(compact('source_type', 'source_id', 'target_type', 'target_id'));
  if ($filter_string = _simplerdf_rel_get_filter_string($filters)) {
    $filter_string = "WHERE $filter_string";
    @db_query("DELETE FROM {simplerdf_rel} $filter_string");
  }
}

/**
 * Look up object relation(s).
 *
 * @param $source_type
 *   Source object type (e.g. node).
 * @param $source_id
 *   Source object ID.
 * @param $target_type
 *   Target object type (e.g. node).
 * @param $target_id
 *   Target object ID.
 *
 * @return array
 *   Array of relation rows filtered by given arguments.
 *
 * @see simplerdf_rel_register()
 * @see simplerdf_rel_unregister()
 */
function simplerdf_rel_lookup($source_type = NULL, $source_id = NULL, $target_type = NULL, $target_id = NULL) {
  $source_id = (int) $source_id;
  $target_id = (int) $target_id;
  $filters = array_filter(compact('source_type', 'source_id', 'target_type', 'target_id'));
  if ($filter_string = _simplerdf_rel_get_filter_string($filters)) {
    $filter_string = "WHERE $filter_string";
  }
  $result = db_query("SELECT * FROM {simplerdf_rel} $filter_string");

  $rels = array();
  while ($rel = db_fetch_array($result)) {
    $rels[] = $rel;
  }
  return $rels;
}

/**
 * Prepare query filter conditions.
 */
function _simplerdf_rel_prepare_filters($raw_filters) {
  $filters = array();
  foreach (array('source_type', 'source_id', 'target_type', 'target_id') as $name) {
    if ($raw_filters[$name]) {
      $filters[$name] = $raw_filters[$name];
    }
  }
  return $filters;
}

/**
 * Render query filter string from condition array.
 */
function _simplerdf_rel_get_filter_string($filters) {
  $string = '';
  foreach ($filters as $name => $value) {
    // Prepare value
    $param = is_integer($value) ? '%d' : "'%s'";
    if (is_integer($value)) {
      $param = $value;
    }
    else {
      $param = "'" . db_escape_string($value) . "'";
    }
    // Construct string
    if (empty($string)) {
      $string = $name . ' = ' . $param;
    }
    else {
      $string .= ' AND ' . $name . ' = ' . $param;
    }
  }
  return $string;
}

/**
 * Implements hook_nodeapi().
 */
function simplerdf_nodeapi(&$node, $op, $a3 = NULL, $a4 = NULL) {
  switch ($op) {
    case 'presave':
      if (!empty($node->nid)) {
        // Clear relations
        simplerdf_rel_unregister('node', $node->nid);
      }
      break;

    case 'update':
      simplerdf_clear_cache('node', $node->nid);
    case 'insert':
      module_invoke_all('simplerdf_rel_save', 'node', $node);
      break;

    case 'delete':
      // Clear cache
      simplerdf_clear_cache('node', $node->nid);
      simplerdf_rel_unregister(NULL, NULL, 'node', $node->nid);
      simplerdf_rel_unregister('node', $node->nid);
      break;

    case 'view':
      // Add autodiscovery link if not in conflict with RDF
      $path = variable_get('simplerdf_view_path', 'rdf');
      if ($a4 && !(module_exists('rdf') && $path == 'rdf')) {
        module_load_include('inc', 'simplerdf', 'includes/simplerdf.arc');
        $format = variable_get('simplerdf_format', SIMPLERDF_DEFAULT_FORMAT);
        if ($mime_type = simplerdf_arc_get_mime_type($format)) {
          drupal_add_link(array('rel' => 'meta', 'type' => $mime_type, 'title' => 'RDF', 'href' => url('node/' . $node->nid . '/' . $path)));
        }
      }
      break;
  }
}

/**
 * Implements hook_simplerdf_rel_save().
 */
function simplerdf_simplerdf_rel_save($type, $object) {
  if ($type == 'node') {
    // Prepare node fields
    $node = &$object;
    $nid = $node->nid;
    $type = content_types($node->type);
    $fields = $type['fields'];

    // Register nodereference links
    foreach ($fields as $field_name => $field) {
      if ($field['type'] == 'nodereference' && isset($node->$field_name)) {
        foreach ($node->$field_name as $delta => $value) {
          if ($value) {
            simplerdf_rel_register('node', $nid, 'node', $value['nid']);
          }
        }
      }
    }
  }
}

/**
 * Implements hook_content_types_overview_alter().
 */
function simplerdf_content_types_overview_alter(&$header, &$rows) {
  module_load_include('inc', 'simplerdf', 'includes/simplerdf.admin');
  _simplerdf_content_types_overview_alter($header, $rows);
}

/**
 * Implements hook_form_alter().
 */
function simplerdf_form_alter(&$form, &$form_state, $form_id) {
  switch ($form_id) {
    case 'content_field_edit_form':
    case 'node_type_form':
      $form['#submit'][] = 'simplerdf_clear_cache_all';
      break;
  }
}

/**
 * Autocomplete callback.
 */
function simplerdf_autocomplete($type = '', $string = '') {
  switch ($type) {
    case 'nid':
      // Match on node ID or title for ID
      $result = db_query("SELECT nid, title FROM {node} WHERE nid LIKE '%%%s%%' OR title LIKE '%%%s%%'", $string, $string);
      $matches = array();
      while ($match = db_fetch_array($result)) {
        $matches[$match['nid']] = "$match[title] (nid: $match[nid])";
      }
      return drupal_json($matches);
  }
}

/**
 * Implements hook_rdf_namespaces().
 */
function simplerdf_rdf_namespaces() {
  static $extra = array(
    'content'  => 'http://purl.org/rss/1.0/modules/content/',
    'sioc'     => 'http://rdfs.org/sioc/ns#',
    'sioct'    => 'http://rdfs.org/sioc/types#',
    'skos'     => 'http://www.w3.org/2004/02/skos/core#',
  );

  if (module_exists('rdf')) {
    // Only return extras that RDF doesn't export
    return $extra;
  }
  else {
    // Define common namespaces, including those RDF defines
    static $rdf = array(
      '_'        => 'http://bnode.net/',
      'rdf'      => 'http://www.w3.org/1999/02/22-rdf-syntax-ns#',
      'rdfs'     => 'http://www.w3.org/2000/01/rdf-schema#',
      'xsi'      => 'http://www.w3.org/2001/XMLSchema-instance#',
      'xsd'      => 'http://www.w3.org/2001/XMLSchema#',
      'owl'      => 'http://www.w3.org/2002/07/owl#',
      'dc'       => 'http://purl.org/dc/elements/1.1/',
      'dcterms'  => 'http://purl.org/dc/terms/',
      'dcmitype' => 'http://purl.org/dc/dcmitype/',
      'foaf'     => 'http://xmlns.com/foaf/0.1/',
      'rss'      => 'http://purl.org/rss/1.0/',
    );
    return $rdf + $extra;
  }
}

/**
 * Helper function to get defined RDF namespaces.
 *
 * @param string $prefix
 *   Only return the namespace with this prefix.
 *
 * @return
 *   Array of namespace URIs keyed by prefixes, or a matching namespace if prefix is specified.
 */
function simplerdf_get_namespaces($prefix = NULL) {
  static $namespaces;
  if (!isset($namespaces)) {
    $namespaces = array();
    foreach (module_implements('rdf_namespaces') as $module) {
      if (is_array($result = module_invoke($module, 'rdf_namespaces'))) {
        $namespaces += $result;
      }
    }
    ksort($namespaces);
  }
  return isset($prefix) ? $namespaces[$prefix] : $namespaces;
}


/************************************************
 * RDF statement helper functions.
 ************************************************/

/**
 * Make a statement subject.
 *
 * @param string $type
 *   Either 'uri' or 'bnode'.
 * @param string $value
 *   Subject value, either a URI or BNode ID. If $type is 'uri', value must be
 *   specified. If type is 'bnode' and the value is not given, a UUID will be
 *   generated in its place.
 *
 * @return array
 *   Array representing statement subject containing keys 's' and 's_type'. If
 *   $type is not 'bnode' and $value is not given, NULL is returned.
 *
 * @see http://arc.semsol.org/docs/v2/structures
 */
function simplerdf_make_subject($type, $value = NULL) {
  if ($type == 'bnode' || isset($value)) {
    if ($type == 'bnode' && !isset($value)) {
      // Generate BNode ID
      $value = '_:' . uuid_uuid();
    }
    return array(
      's' => $value,
      's_type' => $type,
    );
  }
}

/**
 * Make a statement predicate.
 *
 * @param string $property
 *   RDF property URI.
 *
 * @return array
 *   Array containing predicate keyed by 'p'.
 *
 * @see http://arc.semsol.org/docs/v2/structures
 */
function simplerdf_make_predicate($property) {
  return array('p' => $property);
}

/**
 * Make a statement object.
 *
 * @param string $type
 *   One of 'uri', 'bnode', or 'literal'.
 * @param string $value
 *   Subject value, either a URI or BNode ID. If $type is 'uri', value must be
 *   specified. If type is 'bnode' and the value is not given, a UUID will be
 *   generated in its place. If
 * @param string $datatype
 *   (Optional) The value data type URI.
 * @param string $lang
 *   (Optional) Locale identifier, e.g. 'en-us'.
 *
 * @return array
 *   Array containing object with keys: 'o', 'o_type', 'o_datatype', 'o_lang'.
 *   If $type is not 'bnode' and $value is not given, NULL is returned.
 *
 * @see http://arc.semsol.org/docs/v2/structures
 */
function simplerdf_make_object($type, $value = NULL, $datatype = NULL, $lang = NULL) {
  if ($type == 'bnode' || isset($value)) {
    if ($type == 'bnode' && !isset($value)) {
      // Generate BNode ID
      $value = '_:' . uuid_uuid();
    }
    $o = array(
      'o' => $value,
      'o_type' => $type,
    );
    // Insert data type
    if ($datatype) {
      $o['o_datatype'] = $datatype;
    }
    // Insert locale
    if ($lang) {
      $o['o_lang'] = $lang;
    }
    return $o;
  }
}

/**
 * Match a string as URL and clean the URL. This function uses the same pattern
 * Drupal's Filter uses to match URLs from text input.
 *
 * @param string $text
 *   String to match.
 *
 * @return
 *   Cleaned URL, or NULL if given string is not a URL.
 */
function simplerdf_match_url($text) {
  static $pattern = '`^(http://|https://|ftp://|mailto:|smb://|afp://|file://|gopher://|news://|ssl://|sslv2://|sslv3://|tls://|tcp://|udp://)([a-zA-Z0-9@:%_+*~#?&=.,/;-]*[a-zA-Z0-9@:%_+*~#&=/;-])$`i';
  static $cache = array();
  if ($cache[$text]) {
    return $cache[$text];
  }
  elseif (!isset($cache[$text])) {
    // Match as URL
    if (preg_match($pattern, $text)) {
      // Clean and cache
      $url = check_url(decode_entities($text));
      $cache[$text] = $url;
      return $url;
    }
  }
}

/**
 * Match a string as an email address and transform into a mailto: URI. This
 * function uses the same pattern Drupal's Filter uses to match emails.
 *
 * @param string $text
 *   String to match.
 *
 * @return
 *   Email mailto: URI, or NULL if given string is not an email address.
 */
function simplerdf_match_email($text) {
  static $pattern = '`^[A-Za-z0-9._-]+@[A-Za-z0-9._+-]+\.[A-Za-z]{2,4}$`i';
  // Match as email
  if (preg_match($pattern, $text)) {
    return 'mailto:' . $text;
  }
}


/************************************************
 * Plugin declarations.
 ************************************************/

/**
 * Implements hook_ctools_plugin_api().
 */
function simplerdf_ctools_plugin_api($owner, $api) {
  // Default plugins
  if ($owner == 'simplerdf') {
    switch ($api) {
      case 'mappers':
        return array('version' => 1);

      case 'content_mappers':
        return array('version' => 1);

      case 'nodeuri_generators':
        return array('version' => 1);
    }
  }
}

/**
 * Implements hook_ctools_plugin_directory().
 */
function simplerdf_ctools_plugin_directory($owner, $type) {
  // Default plugins
  if ($owner == 'simplerdf') {
    return 'plugins/' . $type;
  }
}

/**
 * Implements hook_ctools_plugin_TYPE() for mappers.
 */
function simplerdf_ctools_plugin_mappers() {
  return array(
    'cache' => TRUE,
    'cache table' => 'cache_simplerdf',
    'use hooks' => TRUE,
    'process' => 'simplerdf_mappers_process',
  );
}

/**
 * Mapper plugin processor.
 */
function simplerdf_mappers_process(&$plugin, $info) {
  $path = drupal_get_path('module', $plugin['module']);

  // Add default values
  $plugin += array(
    'title' => '',
    'description' => '',
    'weight' => 0,
    'callback fields' => NULL,
    'callback fields arguments' => array(),
    'callback fields file' => NULL,
    'callback fields path' => $path,
    'callback map' => NULL,
    'callback map arguments' => array(),
    'callback map file' => NULL,
    'callback map path' => $path,
  );
}

/**
 * Implements hook_ctools_plugin_TYPE() for content_mappers.
 */
function simplerdf_ctools_plugin_content_mappers() {
  return array(
    'cache' => TRUE,
    'cache table' => 'cache_simplerdf',
    'use hooks' => TRUE,
    'process' => 'simplerdf_content_mappers_process',
  );
}

/**
 * Content mapper plugin processor.
 */
function simplerdf_content_mappers_process(&$plugin, $info) {
  $path = drupal_get_path('module', $plugin['module']);

  // Add default values
  $plugin += array(
    'weight' => 0,
    'field modules' => array(),
    'field types' => array(),
    'callback fields' => '_simplerdf_content_mappers_default_fields',
    'callback fields arguments' => array(),
    'callback fields file' => NULL,
    'callback fields path' => $path,
    'callback map' => NULL,
    'callback map arguments' => array(),
    'callback map file' => NULL,
    'callback map path' => $path,
  );
}

/**
 * Default field callback.
 * This returns the basic content field with its name and label title.
 */
function _simplerdf_content_mappers_default_fields($content_field) {
  $field = array(
    'title' => $content_field['widget']['label'],
  );
  return array($content_field['field_name'] => $field);
}

/**
 * Implements hook_ctools_plugin_TYPE() for nodeuri_generators.
 */
function simplerdf_ctools_plugin_nodeuri_generators() {
  return array(
    'cache' => TRUE,
    'cache table' => 'cache_simplerdf',
    'use hooks' => TRUE,
    'process' => 'simplerdf_nodeuri_generators_process',
  );
}

/**
 * Node URI generator plugin processor.
 */
function simplerdf_nodeuri_generators_process(&$plugin, $info) {
  $path = drupal_get_path('module', $plugin['module']);

  // Add default values
  $plugin += array(
    'title' => '',
    'description' => '',
    'weight' => 0,
    'callback generate' => NULL,
    'callback generate arguments' => array(),
    'callback generate file' => NULL,
    'callback generate path' => $path,
    'settings defaults' => array(),
    'settings form' => NULL,
    'settings form validate' => NULL,
  );
}


/************************************************
 * Plugin-related helper functions.
 ************************************************/

/**
 * Invoke a plugin callback.
 */
function _simplerdf_invoke($plugin, $op) {
  // Track which callback files have already been loaded
  static $loaded = array();

  // Pop function arguments manually
  $args = func_get_args();
  $plugin = array_shift($args);
  $op = array_shift($args);

  // Prepare callback arguments
  $args = array_merge($args, $plugin[$op . ' arguments']);

  // Load plugin file
  if (!$loaded[$plugin['name']]['plugin'] && !empty($plugin['file']) && file_exists($plugin_file = $plugin['path'] . '/' . $plugin['file'])) {
    _simplerdf_invoke_include($plugin_file);
    $loaded[$plugin['name']]['plugin'] = TRUE;
  }

  // Include file
  if (!$loaded[$plugin['name']]['ops'][$op] && isset($plugin[$op . ' file']) && file_exists($file = $plugin[$op . ' path'] . '/' . $plugin[$op . ' file'])) {
    _simplerdf_invoke_include($file);
    $loaded[$plugin['name']]['ops'][$op] = TRUE;
  }

  // Invoke callback
  if (function_exists($callback = $plugin[$op])) {
    return call_user_func_array($callback, $args);
  }
}

/**
 * Load a plugin callback file safely.
 */
function _simplerdf_invoke_include($file) {
  // Simply include the file within a function sandbox
  include_once $file;
}

/**
 * Get a list of fields to map.
 *
 * @param string $content_type
 *   Content type name.
 *
 * @return array
 *   Fields available for mapping to properties, keyed by mapper.
 */
function simplerdf_get_fields($content_type) {
  return _simplerdf_build_fields($content_type);
}

/**
 * Lazily build mapper field information.
 *
 * @param string $content_type
 *   Content type name.
 * @param boolean $reset
 *   If TRUE, resets the fields cache.
 *
 * @return array
 *   An array of fields keyed by name (NULL if invalid type).
 */
function _simplerdf_build_fields($content_type, $reset = FALSE) {
  static $fields = array();

  // Internal use only; reset static cache
  if (!isset($content_type)) {
    if ($reset) {
      $fields = array();
    }
    return;
  }

  if ($reset || !isset($fields[$content_type])) {
    // Fetch from cache
    if (!$reset && $cache_fields = cache_get('fields:' . $content_type, 'cache_simplerdf')) {
      $fields[$content_type] = $cache_fields->data;
    }
    // Rebuild cache
    elseif (node_get_types('type', $content_type)) {
      // Fetch and sort plugins
      ctools_include('plugins');
      $plugins = ctools_get_plugins('simplerdf', 'mappers');
      uasort($plugins, '_simplerdf_compare_plugin_weights');

      // Build field data
      $fields[$content_type] = array();
      foreach ($plugins as $plugin_name => $plugin) {
        // Fetch fields
        foreach (_simplerdf_invoke($plugin, 'callback fields', $content_type) as $name => $field) {
          $field['mapper'] = $plugin_name;
          $fields[$content_type][$name] = array('name' => $name) + $field;
        }
      }
      cache_set('fields:' . $content_type, $fields[$content_type], 'cache_simplerdf');
    }
  }
  return $fields[$content_type];
}

/**
 * Get a list of content fields to map.
 *
 * @param string $content_type
 *   Content type name.
 *
 * @return array
 *   Fields available for mapping to properties, keyed by content mapper.
 */
function simplerdf_get_content_fields($content_type) {
  return _simplerdf_build_content_fields($content_type);
}

/**
 * Lazily build content mapper field information.
 *
 * @param string $content_type
 *   Content type name.
 * @param boolean $reset
 *   If TRUE, resets the fields cache.
 *
 * @return array
 *   An array of fields keyed by name (NULL if invalid type).
 */
function _simplerdf_build_content_fields($content_type, $reset = FALSE) {
  static $fields = array();

  // Internal use only; reset static cache
  if (!isset($content_type)) {
    if ($reset) {
      $fields = array();
    }
    return;
  }

  if ($reset || !isset($fields[$content_type])) {
    // Fetch from cache
    if (!$reset && $cache_fields = cache_get('content_fields:' . $content_type, 'cache_simplerdf')) {
      $fields[$content_type] = $cache_fields->data;
    }
    // Rebuild cache
    else {
      // Prepare content types
      $content_type_info = content_types($content_type);
      $content_fields = $content_type_info['fields'];
      if (!empty($content_fields)) {
        // Fetch and sort plugins
        ctools_include('plugins');
        $plugins = ctools_get_plugins('simplerdf', 'content_mappers');
        uasort($plugins, '_simplerdf_compare_plugin_weights');

        // Build field data
        $fields[$content_type] = array();
        foreach ($content_fields as $content_field) {
          $field_name = $content_field['field_name'];
          // Lookup field providers
          $providers = array();
          foreach ($plugins as $plugin_name => $plugin) {
            if (in_array($content_field['module'], $plugin['field modules']) || in_array($content_field['type'], $plugin['field types'])) {
              $providers[] = $plugin_name;
            }
          }
          if (empty($providers)) {
            // Specify default mapper
            $providers[] = 'default';
          }

          // Forward field to plugins providing its type
          foreach ($providers as $plugin_name) {
            $plugin = $plugins[$plugin_name];
            foreach (_simplerdf_invoke($plugin, 'callback fields', $content_field) as $name => $field) {
              $field['mapper'] = 'content';
              $field['field type'] = $content_field['type'];
              $field['field module'] = $content_field['module'];
              $field['content field'] = $field_name;
              $field['content mapper'] = $plugin_name;
              $fields[$content_type][$name] = array('name' => $name) + $field;
            }
          }
        }
        cache_set('content_fields:' . $content_type, $fields[$content_type], 'cache_simplerdf');
      }
    }
  }
  return isset($content_type) ? $fields[$content_type] : $fields;
}

/**
 * Compare two mappers on weights.
 */
function _simplerdf_compare_plugin_weights($a, $b) {
  return $a['weight'] - $b['weight'];
}

/**
 * Get RDF mappings for a content type.
 *
 * @param string $content_type
 *   Content type name.
 *
 * @return array
 *   Mappings keyed by field name.
 */
function simplerdf_get_mappings($content_type) {
  if ($cache = cache_get('mappings:' . $content_type, 'cache_simplerdf')) {
    // Fetch cached mappings
    return $cache->data;
  }
  else {
    // Build cache
    $result = db_query("SELECT * FROM {simplerdf_mappings} WHERE content_type = '%s' ORDER BY field ASC", $content_type);
    $mappings = array();
    while ($mapping = db_fetch_object($result)) {
      $mappings[$mapping->field] = unserialize($mapping->properties);
    }
    cache_set('mappings:' . $content_type, $mappings, 'cache_simplerdf');
    return $mappings;
  }
}

/**
 * Build RDF triples for a node.
 *
 * @param stdClass $node
 *   Node object.
 *
 * @return array
 *   Namespace-prefixed RDF triples.
 */
function simplerdf_build_triples($node) {
  $type = $node->type;

  // Generate node URI
  $uri = simplerdf_get_nodeuri($node->nid);

  $fields = simplerdf_get_fields($type);
  $mappings = simplerdf_get_mappings($type);

  // Map each field
  $triples = array();
  foreach ($fields as $field_name => $field) {
    if (isset($mappings[$field_name])) {
      $triples = array_merge($triples, simplerdf_map_field($node, $uri, $mappings[$field_name], $field));
    }
  }

  // Give modules a chance to perform some hardcore postprocessing
  drupal_alter('simplerdf_triples', $triples, $node, $nodeuri);

  return $triples;
}

/**
 * Map a node field to an RDF property and generate RDF triples.
 *
 * @param stdClass $node
 *   Node object.
 * @param string $nodeuri
 *   Node URI as RDF statement subject.
 * @param array $properties
 *   An array of RDF properties as predicates.
 * @param array $field
 *   Mapping field.
 *
 * @return array
 *   RDF triples in the format specified by the ARC2 library, with the
 *   exception of the use of the variable type for any part of the triple.
 *
 * @see http://arc.semsol.org/docs/v2/structures
 */
function simplerdf_map_field($node, $nodeuri, $properties, $field) {
  ctools_include('plugins');

  // Map field
  $plugin = ctools_get_plugins('simplerdf', 'mappers', $field['mapper']);
  $triples = array();
  foreach ($properties as $property) {
    $result = _simplerdf_invoke($plugin, 'callback map', $node, $nodeuri, $property, $field);
    if (is_array($result) && !empty($result)) {
      $triples = array_merge($triples, $result);
    }
  }

  return $triples;
}

/**
 * Get URI of node to represent node. If the active generator failed to produce
 * a URI, a default will be generated using the raw generator.
 *
 * @param int $nid
 *   Node ID.
 *
 * @return string
 *   Node URI.
 */
function simplerdf_get_nodeuri($nid) {
  // Use active node URI generator
  $generator = variable_get('simplerdf_nodeuri_generator', SIMPLERDF_DEFAULT_NODEURI_GENERATOR);

  if ($cache = cache_get('node:' . $nid . ':uri:' . $generator, 'cache_simplerdf')) {
    // Fetch cached URI
    return $cache->data;
  }
  else {
    // Generate using active URI generator
    $uri = simplerdf_generate_nodeuri($generator, $nid);
    if (empty($uri)) {
      // Failed; fall back to raw generator
      simplerdf_generate_nodeuri('raw', $nid);
    }
    cache_set('node:' . $nid . ':uri:' . $generator, $uri, 'cache_simplerdf');
    return $uri;
  }
}

/**
 * Generate node URI using a specific generator.
 *
 * @param string $generator
 *   Name of generator.
 * @param int $nid
 *   Node ID.
 *
 * @return
 *   Node URI string, or NULL if generation failed.
 */
function simplerdf_generate_nodeuri($generator, $nid) {
  ctools_include('plugins');

  // Generate using active URI generator
  $plugin = ctools_get_plugins('simplerdf', 'nodeuri_generators', $generator);
  $settings = (array) variable_get('simplerdf_nodeuri_settings', array());
  if (!isset($settings[$generator])) {
    $settings[$generator] = array();
  }
  $settings[$generator] += $plugin['settings defaults'];

  if ($uri = _simplerdf_invoke($plugin, 'callback generate', $nid, $settings[$generator])) {
    return $uri;
  }
}

/**
 * Generate raw or aliased node URI.
 *
 * @param int $nid
 *   Node ID.
 * @param array $settings
 *   Settings (should be empty).
 * @param string $type
 *   Type of path to generate. Value is either 'raw' or 'alias'.
 *
 * @return string
 *   Node URI.
 */
function _simplerdf_get_nodeuri($nid, $settings, $type) {
  $options = array('absolute' => TRUE);
  if ($type == 'raw') {
    // Raw path
    $options['alias'] = TRUE;
    return url('node/' . $nid, $options);
  }
  elseif ($type == 'alias') {
    // Aliased path
    return url('node/' . $nid, $options);
  }
}
